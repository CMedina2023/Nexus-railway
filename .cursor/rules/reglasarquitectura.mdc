---
alwaysApply: true
---
# ğŸ“ GUÃAS DE ARQUITECTURA Y OPTIMIZACIÃ“N - NEXUS AI

> **PropÃ³sito**: Este documento define las directrices de arquitectura, diseÃ±o y optimizaciÃ³n que deben seguirse en el proyecto para mantener alta calidad, mantenibilidad y escalabilidad.

**Ãšltima actualizaciÃ³n**: 2025-11-21  
**VersiÃ³n**: 1.0

---

## ğŸ“‹ TABLA DE CONTENIDOS

1. [Principios Fundamentales](#principios-fundamentales)
2. [Estructura del Proyecto](#estructura-del-proyecto)
3. [Patrones de DiseÃ±o](#patrones-de-diseÃ±o)
4. [Convenciones de CÃ³digo](#convenciones-de-cÃ³digo)
5. [Mejores PrÃ¡cticas](#mejores-prÃ¡cticas)
6. [Checklist de Desarrollo](#checklist-de-desarrollo)
7. [Anti-Patrones a Evitar](#anti-patrones-a-evitir)

---

## ğŸ¯ PRINCIPIOS FUNDAMENTALES

### 1. SOLID Principles

**SIEMPRE aplicar los principios SOLID en todo el cÃ³digo:**

#### âœ… Single Responsibility Principle (SRP)
- **Una clase/servicio = Una responsabilidad Ãºnica**
- Si una clase tiene mÃ¡s de una razÃ³n para cambiar, dividirla
- **Ejemplo**: `FileManager` solo maneja archivos, `DocumentAnalyzer` solo analiza documentos

```python
# âœ… CORRECTO
class FileManager:
    """Solo maneja archivos"""
    def save_file(self): ...
    def delete_file(self): ...

# âŒ INCORRECTO
class FileManager:
    """Maneja archivos Y anÃ¡lisis Y validaciÃ³n"""
    def save_file(self): ...
    def analyze_content(self): ...  # âŒ Responsabilidad extra
    def validate_data(self): ...    # âŒ Responsabilidad extra
```

#### âœ… Open/Closed Principle (OCP)
- **Extensible sin modificar cÃ³digo existente**
- Usar interfaces y abstracciones
- **Ejemplo**: `Generator` interface permite agregar nuevos generadores sin cambiar cÃ³digo existente

```python
# âœ… CORRECTO - Usar interfaces
class Generator(ABC):
    @abstractmethod
    def generate(self, text, params): ...

class StoryGenerator(Generator): ...
class MatrixGenerator(Generator): ...
# Puedes agregar CustomGenerator sin modificar cÃ³digo existente

# âŒ INCORRECTO - LÃ³gica hardcodeada
def generate_content(type):
    if type == 'story':
        # lÃ³gica...
    elif type == 'matrix':
        # lÃ³gica...
    # âŒ Necesitas modificar esta funciÃ³n para agregar nuevos tipos
```

#### âœ… Liskov Substitution Principle (LSP)
- **Las clases derivadas deben ser sustituibles por sus clases base**
- Mantener contratos de interfaces
- **Ejemplo**: Cualquier `Generator` puede usarse donde se espera `Generator`

#### âœ… Interface Segregation Principle (ISP)
- **Interfaces pequeÃ±as y especÃ­ficas, no monolÃ­ticas**
- Los clientes no deben depender de mÃ©todos que no usan
- **Ejemplo**: Servicios Jira separados (`ProjectService`, `IssueService`) en lugar de un `JiraClient` gigante

#### âœ… Dependency Inversion Principle (DIP)
- **Depender de abstracciones, no de implementaciones concretas**
- Inyectar dependencias en lugar de crear instancias directamente
- **Ejemplo**: Servicios reciben `JiraConnection` en lugar de crear su propia conexiÃ³n

```python
# âœ… CORRECTO - InyecciÃ³n de dependencias
class ProjectService:
    def __init__(self, connection: JiraConnection):
        self._connection = connection

# âŒ INCORRECTO - Dependencia directa
class ProjectService:
    def __init__(self):
        self._connection = JiraConnection()  # âŒ Acoplamiento fuerte
```

---

### 2. DRY (Don't Repeat Yourself)

**NUNCA duplicar cÃ³digo:**
- âœ… Extraer funciones comunes a servicios/utilidades
- âœ… Usar decoradores para lÃ³gica repetida
- âœ… Crear clases base para funcionalidad compartida
- âœ… Usar constantes en lugar de valores mÃ¡gicos

**Ejemplo**: `DocumentChunker` unificado en lugar de `split_document_into_chunks()` duplicado en mÃºltiples archivos.

---

### 3. YAGNI (You Aren't Gonna Need It)

**No sobre-ingeniar:**
- Implementar solo lo necesario para el requerimiento actual
- Evitar funcionalidad "por si acaso"
- Refactorizar cuando sea realmente necesario

---

### 4. KISS (Keep It Simple, Stupid)

**Simplicidad sobre complejidad:**
- Soluciones simples y claras
- CÃ³digo que se auto-explica
- Evitar optimizaciones prematuras

---

## ğŸ“ ESTRUCTURA DEL PROYECTO

### Estructura Actual (MANTENER):

```
app/
â”œâ”€â”€ backend/              # LÃ³gica de negocio y backend
â”‚   â”œâ”€â”€ generators/       # Generadores con OCP
â”‚   â”œâ”€â”€ jira/            # Servicios Jira especializados
â”‚   â””â”€â”€ ...
â”œâ”€â”€ core/                # ConfiguraciÃ³n y app principal
â”‚   â”œâ”€â”€ app.py           # Endpoints Flask (DELGADOS)
â”‚   â”œâ”€â”€ config.py        # ConfiguraciÃ³n centralizada
â”‚   â””â”€â”€ service_factory.py
â”œâ”€â”€ services/            # Servicios de negocio (SRP)
â”‚   â”œâ”€â”€ file_manager.py
â”‚   â”œâ”€â”€ document_analyzer.py
â”‚   â”œâ”€â”€ data_transformer.py
â”‚   â”œâ”€â”€ validator.py
â”‚   â””â”€â”€ ...
â””â”€â”€ utils/               # Utilidades y helpers
    â”œâ”€â”€ decorators.py    # Decoradores reutilizables
    â”œâ”€â”€ document_chunker.py
    â”œâ”€â”€ exceptions.py
    â””â”€â”€ ...
```

### Reglas de Estructura:

1. **`app/core/app.py`**: 
   - Solo endpoints Flask (DELGADOS)
   - Delega lÃ³gica a servicios
   - MÃ¡ximo 20 lÃ­neas por endpoint

2. **`app/services/`**: 
   - Servicios de negocio con SRP
   - Un servicio = Una responsabilidad
   - Sin dependencias de Flask directamente

3. **`app/backend/`**: 
   - Integraciones externas (Jira, AI, etc.)
   - Generadores y procesadores especÃ­ficos

4. **`app/utils/`**: 
   - Utilidades reutilizables
   - Decoradores comunes
   - Helpers genÃ©ricos

---

## ğŸ¨ PATRONES DE DISEÃ‘O

### 1. Factory Pattern

**Usar para creaciÃ³n de objetos complejos:**

```python
# âœ… CORRECTO
class GeneratorFactory:
    def get_generator(self, task_type: str) -> Generator:
        # LÃ³gica de creaciÃ³n

# Uso
factory = GeneratorFactory()
generator = factory.get_generator('story')
```

### 2. Dependency Injection

**Inyectar dependencias en constructores:**

```python
# âœ… CORRECTO
class ProjectService:
    def __init__(self, connection: JiraConnection, metrics_calculator: MetricsCalculator):
        self._connection = connection
        self._metrics_calculator = metrics_calculator
```

### 3. Strategy Pattern

**Para algoritmos intercambiables:**

```python
# âœ… CORRECTO
class DocumentChunker:
    def __init__(self, strategy: ChunkingStrategy):
        self.strategy = strategy
    
    def split(self, text):
        if self.strategy == ChunkingStrategy.SMART:
            return self._split_smart(text)
        # ...
```

### 4. Decorator Pattern

**Para funcionalidad cross-cutting:**

```python
# âœ… CORRECTO
@validate_file_upload
@handle_errors("Error procesando archivo")
def process_file():
    # LÃ³gica
```

---

## ğŸ“ CONVENCIONES DE CÃ“DIGO

### Nomenclatura

1. **Clases**: PascalCase
   ```python
   class FileManager: ...
   class DocumentAnalyzer: ...
   ```

2. **Funciones/MÃ©todos**: snake_case
   ```python
   def save_uploaded_file(): ...
   def calculate_metrics(): ...
   ```

3. **Constantes**: UPPER_SNAKE_CASE
   ```python
   FINAL_STATUSES = {...}
   MAX_CHUNK_SIZE = 3000
   ```

4. **Privados**: Prefijo `_`
   ```python
   def _internal_method(self): ...  # Privado
   def public_method(self): ...     # PÃºblico
   ```

5. **MÃ³dulos**: snake_case
   ```python
   file_manager.py
   document_analyzer.py
   ```

### DocumentaciÃ³n

**SIEMPRE documentar:**
- Docstrings en todas las clases y funciones pÃºblicas
- Type hints en funciones
- Comentarios para lÃ³gica compleja

```python
def process_document(document_text: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
    """
    Procesa un documento y genera contenido.
    
    Args:
        document_text: Texto del documento a procesar
        parameters: ParÃ¡metros de generaciÃ³n
        
    Returns:
        Dict con el resultado del procesamiento
        
    Raises:
        ValidationError: Si el documento no es vÃ¡lido
    """
    # ImplementaciÃ³n
```

### Imports

**Orden de imports:**
1. Standard library
2. Third-party packages
3. Local application imports

```python
# Standard library
import os
import logging
from typing import Dict, List

# Third-party
from flask import Flask, request
import requests

# Local
from app.services.file_manager import FileManager
from app.core.config import Config
```

---

## âœ… MEJORES PRÃCTICAS

### 1. ConfiguraciÃ³n Centralizada

**SIEMPRE usar `Config` para valores configurables:**

```python
# âœ… CORRECTO
from app.core.config import Config
timeout = Config.JIRA_TIMEOUT_SHORT

# âŒ INCORRECTO
timeout = 10  # âŒ Valor hardcodeado
```

### 2. Manejo de Errores

**Usar decoradores para manejo consistente:**

```python
# âœ… CORRECTO
@handle_errors("Error procesando solicitud", status_code=500)
def process_request():
    # LÃ³gica
```

**Lanzar excepciones personalizadas:**

```python
from app.utils.exceptions import ValidationError

if not valid:
    raise ValidationError("Datos invÃ¡lidos")
```

### 3. Logging

**SIEMPRE usar logging en lugar de print:**

```python
# âœ… CORRECTO
logger.info("Procesando documento")
logger.error(f"Error: {e}", exc_info=True)
logger.debug(f"Debug info: {data}")

# âŒ INCORRECTO
print("Procesando documento")  # âŒ No usar print
```

**Niveles de logging:**
- `logger.debug()`: InformaciÃ³n detallada de debugging
- `logger.info()`: Eventos informativos normales
- `logger.warning()`: Advertencias que no impiden funcionamiento
- `logger.error()`: Errores que impiden alguna funcionalidad
- `logger.critical()`: Errores crÃ­ticos que pueden detener la aplicaciÃ³n

### 4. ValidaciÃ³n

**Validar siempre en la entrada:**
- Validar archivos subidos con `@validate_file_upload`
- Validar parÃ¡metros requeridos con `@validate_required_params`
- Validar datos con servicios `Validator`

### 5. Reintentos

**Usar decorador de reintentos para operaciones externas:**

```python
# âœ… CORRECTO
@retry_on_failure(max_retries=3, delay=2.0)
def call_external_api():
    # LÃ³gica con posible fallo de red
```

### 6. Limpieza de Recursos

**SIEMPRE limpiar recursos temporales:**

```python
# âœ… CORRECTO
try:
    filepath = save_file(file)
    # Procesar
finally:
    file_manager.clean_temp_file(filepath)
```

---

## ğŸ“‹ CHECKLIST DE DESARROLLO

### Antes de Escribir CÃ³digo:

- [ ] Â¿Estoy siguiendo SRP? (Una clase = Una responsabilidad)
- [ ] Â¿Puedo usar un servicio existente en lugar de crear nuevo cÃ³digo?
- [ ] Â¿El cÃ³digo es extensible sin modificar existente? (OCP)
- [ ] Â¿Estoy inyectando dependencias en lugar de crear instancias directamente?
- [ ] Â¿Estoy usando `Config` para valores configurables?

### Durante el Desarrollo:

- [ ] Â¿Estoy documentando con docstrings?
- [ ] Â¿Estoy usando type hints?
- [ ] Â¿Estoy usando logging en lugar de print?
- [ ] Â¿Estoy manejando errores apropiadamente?
- [ ] Â¿Estoy validando entradas?

### Antes de Hacer Commit:

- [ ] Â¿El cÃ³digo sigue las convenciones de nomenclatura?
- [ ] Â¿No hay cÃ³digo duplicado? (DRY)
- [ ] Â¿Hay tests para la funcionalidad?
- [ ] Â¿El cÃ³digo pasa el linter sin errores?
- [ ] Â¿Las importaciones estÃ¡n ordenadas correctamente?
- [ ] Â¿Los recursos temporales se estÃ¡n limpiando?

### RevisiÃ³n de CÃ³digo:

- [ ] Â¿El cÃ³digo es legible y auto-explicativo?
- [ ] Â¿Las funciones son cortas (< 50 lÃ­neas preferiblemente)?
- [ ] Â¿Las clases tienen responsabilidades claras?
- [ ] Â¿El acoplamiento entre mÃ³dulos es bajo?
- [ ] Â¿La cohesiÃ³n dentro de mÃ³dulos es alta?

---

## ğŸš« ANTI-PATRONES A EVITAR

### 1. God Class / God Object

**âŒ NUNCA:**
```python
class Everything:
    def handle_files(self): ...
    def analyze_documents(self): ...
    def process_data(self): ...
    def generate_reports(self): ...
    def manage_database(self): ...
    # âŒ Demasiadas responsabilidades
```

**âœ… SIEMPRE:**
```python
class FileManager: ...
class DocumentAnalyzer: ...
class DataTransformer: ...
class ReportGenerator: ...
# âœ… Una responsabilidad por clase
```

### 2. Magic Numbers

**âŒ NUNCA:**
```python
if len(text) > 3000:  # âŒ Â¿Por quÃ© 3000?
    # ...
time.sleep(2)  # âŒ Â¿Por quÃ© 2 segundos?
```

**âœ… SIEMPRE:**
```python
if len(text) > Config.STORY_MAX_CHUNK_SIZE:
    # ...
time.sleep(Config.RETRY_DELAY)
```

### 3. Code Duplication

**âŒ NUNCA:**
```python
# FunciÃ³n duplicada en mÃºltiples archivos
def split_text(text):
    # LÃ³gica duplicada
```

**âœ… SIEMPRE:**
```python
# Servicio unificado
from app.utils.document_chunker import split_document_into_chunks
```

### 4. Hardcoded Credentials

**âŒ NUNCA:**
```python
api_key = "sk-1234567890abcdef"  # âŒ NUNCA hardcodear credenciales
```

**âœ… SIEMPRE:**
```python
api_key = Config.GOOGLE_API_KEY  # âœ… De variables de entorno
```

### 5. Deep Nesting

**âŒ NUNCA:**
```python
if condition1:
    if condition2:
        if condition3:
            if condition4:
                # âŒ Demasiado anidado
```

**âœ… SIEMPRE:**
```python
if not condition1:
    return

if not condition2:
    return

# âœ… Early returns, guard clauses
```

### 6. Large Functions

**âŒ NUNCA:**
```python
def process_everything():
    # 200+ lÃ­neas de cÃ³digo  # âŒ FunciÃ³n gigante
    # ...
```

**âœ… SIEMPRE:**
```python
def process_everything():
    # FunciÃ³n orquestadora delgada
    data = extract_data()
    validated = validate_data(data)
    return transform_data(validated)
```

### 7. Tight Coupling

**âŒ NUNCA:**
```python
class ServiceA:
    def __init__(self):
        self.service_b = ServiceB()  # âŒ Dependencia directa
```

**âœ… SIEMPRE:**
```python
class ServiceA:
    def __init__(self, service_b: ServiceB):  # âœ… InyecciÃ³n
        self.service_b = service_b
```

---

## ğŸ” REVISIÃ“N DE CÃ“DIGO - PUNTOS CLAVE

### Cuando Revisar CÃ³digo Propio o de Otros:

1. **Â¿Sigue SRP?** - Â¿La clase hace solo una cosa?
2. **Â¿Hay duplicaciÃ³n?** - Â¿Se puede extraer a un servicio comÃºn?
3. **Â¿EstÃ¡ bien acoplado?** - Â¿Las dependencias estÃ¡n inyectadas?
4. **Â¿Es testeable?** - Â¿Se puede testear fÃ¡cilmente?
5. **Â¿Es extensible?** - Â¿Se puede extender sin modificar?
6. **Â¿EstÃ¡ documentado?** - Â¿Hay docstrings y comentarios claros?
7. **Â¿Maneja errores?** - Â¿Hay manejo apropiado de excepciones?

---

## ğŸ“š REFERENCIAS Y RECURSOS

### DocumentaciÃ³n del Proyecto:

- `RESUMEN_FINAL_REFACTORIZACION.md` - Cambios implementados
- `docs/README.md` - DocumentaciÃ³n tÃ©cnica
- `tests/README.md` - GuÃ­a de testing

### Principios y Patrones:

- **SOLID Principles**: https://en.wikipedia.org/wiki/SOLID
- **Design Patterns**: https://refactoring.guru/design-patterns
- **Clean Code**: Robert C. Martin
- **Refactoring**: Martin Fowler

---

## ğŸ“ CONTACTO Y SOPORTE

Si tienes dudas sobre cÃ³mo aplicar estas guÃ­as o necesitas aclarar algÃºn punto, consulta:

1. Este documento primero
2. El cÃ³digo existente como referencia
3. Los servicios creados como ejemplos

---

## âœ… COMPROMISO

**Al trabajar en este proyecto, me comprometo a:**

- âœ… Seguir estas guÃ­as en todo el cÃ³digo nuevo
- âœ… Refactorizar cÃ³digo existente cuando sea necesario
- âœ… Revisar cÃ³digo propio antes de hacer commit
- âœ… Aplicar principios SOLID consistentemente
- âœ… Mantener alta calidad y mantenibilidad

---

**Recordatorio**: Estas guÃ­as no son opcionales, son **ESTÃNDARES** del proyecto. Todo el cÃ³digo debe seguir estos principios para mantener la calidad y escalabilidad del sistema.

---

*Ãšltima actualizaciÃ³n: 2025-11-21*  
*VersiÃ³n: 1.0*

